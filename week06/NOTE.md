学习笔记

递归代码步骤：
	1.终止条件
	2.处理当前层
	3.下探到下一层
	4.恢复当前层状态（非必要）
	
	

分治代码步骤：
	1.终止条件
	2.拆分子问题
	3.调子问题的递归函数
	4.合并子问题的结果
	5.恢复当前层状态（非必要）
	
感触：
	1.人肉递归低效、很累
	2.找到最近最简方法，将其拆分成可重复解决的问题
	3.数学归纳法思维（抵制人肉递归的诱惑）

	
	
动态规划 Dynamic Programming	
	
关键点： 

	1. 动态规划和递归或者分治没有根本上的区别(关键看有无最优的子结构)
	2. 共性：找到重复子问题
	3. 差异性 最优子结构、中途可以淘汰次优解
	
	
	
斐波拉契数列：fib(n) = fib(n-1) + fib(n-2)
	
	int fib(int n) {
		return n<=1?n:fib(n-1)+fib(n-2)
	}
	
加入缓存解决重复性计算	(记忆化搜索) 时间复杂度从O(2^n) 变成了O(n) (自顶向下)


// -----------
`F[n] = F[n-1]+F[n-2]
`a[0]=0, a[1]=1;
for(int i=2; i<=n; ++i) {
	a[i]=a[i-1]+a[i-2]
}
// --------------Bottom Up(自底向上) 

	
	
	
	
binary_search c++库自带的二分查找	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	