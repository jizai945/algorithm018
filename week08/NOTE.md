# 学习笔记

## 位运算：
​	位运算符
​	算数移位与逻辑移位
​	位运算的应用

	判断奇偶：
		X%2==1 --> (X&1) == 1
		X%2==0 --> (X&1) == 0
		
		X>>1 --> X/2
			即: X = X/2; --> X=X>>1;
			mid = (left+right)/2; --> mid = (left+right) >> 1;
			
		X=X&(X-1) 清零最低位的1
		
		X&-X=>得到最低为的1
		
		X&~X=>0

## N皇后的问题最优解使用位运算处理：

```pyt
def totalNQueens(self, n):
	if n < 1: return []
	self,count = 0
	self.DFS(n, 0, 0, 0, 0)
	return self.count
	
def DFS(self, n, row, cols, pie, na):

#recursion terminator

​	if row >= n:
​		self.count += 1
​		return
```


		

	bits = (~(cols | pie | na)) & ((1<<n) - 1)	
	
	while bits:
		p = bits & -bits #取到最低位的1
		bits = bits & (bits - 1) #表示p位置上放入皇后
		self.DFS(n, row+1, cols|p, (pie|p)<<1, (na|p)>>1)
		# 不需要revert cols, pie, na 的状态


​		
## 比特位计数	


​		
布隆过滤器(Bloom Filter)和LRU Cache	


	Bloom Filter VS Hash Table
	
	是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于
	检索一个元素是否在一个集合中
	优点是控件效率和查询时间都远远超过一般的算法
	缺点是有一定的误识别率和删除困难
	
	案例：
		1. 比特币网络
		2. 分布式系统(Map-Reduce) - Hadoop searchengine
		3. Redis缓存
		4. 垃圾邮件、评论等的过滤

Cache 缓存		
	1. 记忆
	2. 钱包-储物柜
	3. 代码模块
	
LFU
	
LRU Cache - least recently used 最近最少使用（双向链表）

	两个要素： 大小、替换策略
	Hash Table + Double LinkedList
	
	O(1) 查询
	O(1) 修改、更新


​	
​	
排序算法:
​	1. 比较类排序
​		通过比较来决定元素的相对次序,由于其时间复杂度不能突破O(nlongn)
​		因此也称为非线性时间比较类排序
​	
​	
	----交换排序：
			冒泡排序  快速排序
		
		插入排序
			简单插入排序 希尔排序
			
		选择排序
			简单选择排序 堆排序
			
		归并排序
			二路归并排序 多路归并排序
	
	2. 非比较类排序
		不通过比较来决定元素的相对次序，它可以突破基于比较排序的时间
		下界，以线性时间运行，因此也称为线性时间非比较类排序


​	
	----计数排序
	
		桶排序
		
		基数排序


重点看一下 堆排序 快速排序 归并排序	
	

| 排序算法        | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 是否稳定 |
| --------------- | -------------- | -------------- | ---------- | -------- |
| 冒泡排序        | O（n2）        | O（n^2）       | O（1）     | 是       |
| 选择排序        | O（n2）        | O（n^2)        | O（1）     | 不是     |
| 希尔排序        | O(n^1.3)       | O（n^2）       | O（1）     | 不是     |
| 直接插入排序    | O（n2）        | O（n^2）       | O（1）     | 是       |
| **归并排序** ** | O（nlogn）     | O（nlogn）     | O(n)       | 是       |
| **快速排序** ** | O（nlogn）     | O（n^2）       | O（logn）  | 不是     |
| **堆排序** **   | O（nlogn）     | O（nlogn）     | O（1）     | 不是     |
|                 |                |                |            |          |
| 计数排序        | O(n+k)         | O(n+k)         | O(n+k)     | 是       |
| 基数排序        | O(N*M)         | O(N*M)         | O(M)       | 是       |
| 桶排序          | O(n+k)         | O(n^2)         | O(n+k)     | 是       |

	初级排序 -- O(N^2)
		1. 选择排序
			每次找最小值，然后放到待排序数组的起始位置
			
		2. 插入排序
			从前到后逐步构建有序序列,对于未排序数据，在已排序的序列中从后
			向前扫描，找到相应位置并插入
		
		3. 冒泡排序
			嵌套循环，每次查看相邻的元素如果逆序，则交换


​	
	高级排序 - O(N*logN)
		快速排序 (quick sort)
			数组取标杆pivot，将小元素pivot放在左边,大元素放右侧，然后依次对右边和右边的
			子数组继续快排 以达到整个序列有序


​	
​	
		归并排序(Merge Sort) -- 分治
		
			1. 把长度为n的输入序列分为两个长度为n/2的子序列
			2. 对这两个子序列分别采用归并排序
			3. 将两个排序好的子序列合并成一个最终的排序序列


​			
		归并 和 快排具有相似性，但步骤相反
			归并：先排序左右子数组，然后合并两个有序子数组
			快排：先调配出左右子数组，然后对于左右子数组进行排序


​		
		堆排序 (Heap Sort)  - 堆插入 O(logN),  取最大/最小值O(1)
			1. 数组元素一次建立小顶堆
			2. 以此取堆顶元素,并删除


​		
​		
​		
​		
​		
​		
​		
​		
​		
​		
​		
​		
​		
​		
​	